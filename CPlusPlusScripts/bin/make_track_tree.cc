/*

Makes track-based flat tree to train/test/validate etc the BTV track selection for the b-taggers (NOT IVF)

Author: M. Verzetti, U. Rochester

 */

#include <boost/program_options.hpp>
#include <map>
#include <string>
#include <stdexcept>
#include <iostream>
#include "TFile.h"
#include "TTree.h"
#include "TChain.h"
#include <vector>
namespace po = boost::program_options;
using namespace std;

int main(int argc, char *argv[]) {
	//treat arguments
	po::positional_options_description args;
  args.add("output", 1);
  args.add("input", -1);

	po::options_description desc("Allowed options");
	desc.add_options()
		("help", "produce help message")
		("output", po::value<string>(), "output file name")
		("input", po::value<vector<string> >()->multitoken(), "input file name")
		;

	po::variables_map vars;        
	po::store(po::command_line_parser(argc, argv).options(desc).positional(args).run(),
						vars);
	po::notify(vars);    

	if (vars.count("help")) {
		cout << "Usage: make_track_tree input output" << endl; 
		cout << desc << "\n";
		return 0;
	}

	//open input files
	TChain * intree = new TChain("btagana/ttree");
	auto infiles = vars["input"].as<vector<string> >();
	for(auto i : infiles) {
		cout << "Adding " << i << " to the input files" << endl;
		intree->Add(i.c_str());
	}

	//Now a long and painful list of variables that we need, because root!
	//automatically generated by a 10 line python script
	intree->SetBranchStatus("*", 0);	
	Int_t Evt=0; intree->SetBranchStatus("Evt", 1); intree->SetBranchAddress("Evt", &Evt);
  Int_t LumiBlock=0; intree->SetBranchStatus("LumiBlock", 1); intree->SetBranchAddress("LumiBlock", &Evt);
	bool lheFilter=0; intree->SetBranchStatus("lheFilter", 1); intree->SetBranchAddress("lheFilter", &lheFilter);
	float mcweight=0; intree->SetBranchStatus("mcweight", 1); intree->SetBranchAddress("mcweight", &mcweight);
	int nPV=0; intree->SetBranchStatus("nPV", 1); intree->SetBranchAddress("nPV", &nPV);
	float rho=0; intree->SetBranchStatus("rho", 1); intree->SetBranchAddress("rho", &rho);
	int nJet=0; intree->SetBranchStatus("nJet", 1); intree->SetBranchAddress("nJet", &nJet);
	float Jet_pt[10000]; intree->SetBranchStatus("Jet_pt", 1); intree->SetBranchAddress("Jet_pt", Jet_pt);
	float Jet_eta[10000]; intree->SetBranchStatus("Jet_eta", 1); intree->SetBranchAddress("Jet_eta", Jet_eta);
	float Jet_phi[10000]; intree->SetBranchStatus("Jet_phi", 1); intree->SetBranchAddress("Jet_phi", Jet_phi);
	int Jet_flavour[10000]; intree->SetBranchStatus("Jet_flavour", 1); intree->SetBranchAddress("Jet_flavour", Jet_flavour);
	int Jet_nbHadrons[10000]; intree->SetBranchStatus("Jet_nbHadrons", 1); intree->SetBranchAddress("Jet_nbHadrons", Jet_nbHadrons);
	int Jet_ncHadrons[10000]; intree->SetBranchStatus("Jet_ncHadrons", 1); intree->SetBranchAddress("Jet_ncHadrons", Jet_ncHadrons);
	int Jet_nFirstTrack[10000]; intree->SetBranchStatus("Jet_nFirstTrack", 1); intree->SetBranchAddress("Jet_nFirstTrack", Jet_nFirstTrack);
	int Jet_nLastTrack[10000]; intree->SetBranchStatus("Jet_nLastTrack", 1); intree->SetBranchAddress("Jet_nLastTrack", Jet_nLastTrack);
	int nTrack=0; intree->SetBranchStatus("nTrack", 1); intree->SetBranchAddress("nTrack", &nTrack);
	float Track_dxy[10000]; intree->SetBranchStatus("Track_dxy", 1); intree->SetBranchAddress("Track_dxy", Track_dxy);
	float Track_dz[10000]; intree->SetBranchStatus("Track_dz", 1); intree->SetBranchAddress("Track_dz", Track_dz);
	float Track_length[10000]; intree->SetBranchStatus("Track_length", 1); intree->SetBranchAddress("Track_length", Track_length);
	float Track_dist[10000]; intree->SetBranchStatus("Track_dist", 1); intree->SetBranchAddress("Track_dist", Track_dist);
	float Track_IP2D[10000]; intree->SetBranchStatus("Track_IP2D", 1); intree->SetBranchAddress("Track_IP2D", Track_IP2D);
	float Track_IP2Dsig[10000]; intree->SetBranchStatus("Track_IP2Dsig", 1); intree->SetBranchAddress("Track_IP2Dsig", Track_IP2Dsig);
	float Track_IP2Derr[10000]; intree->SetBranchStatus("Track_IP2Derr", 1); intree->SetBranchAddress("Track_IP2Derr", Track_IP2Derr);
	float Track_IP[10000]; intree->SetBranchStatus("Track_IP", 1); intree->SetBranchAddress("Track_IP", Track_IP);
	float Track_IPsig[10000]; intree->SetBranchStatus("Track_IPsig", 1); intree->SetBranchAddress("Track_IPsig", Track_IPsig);
	float Track_IPerr[10000]; intree->SetBranchStatus("Track_IPerr", 1); intree->SetBranchAddress("Track_IPerr", Track_IPerr);
	float Track_Proba[10000]; intree->SetBranchStatus("Track_Proba", 1); intree->SetBranchAddress("Track_Proba", Track_Proba);
	float Track_p[10000]; intree->SetBranchStatus("Track_p", 1); intree->SetBranchAddress("Track_p", Track_p);
	float Track_pt[10000]; intree->SetBranchStatus("Track_pt", 1); intree->SetBranchAddress("Track_pt", Track_pt);
	float Track_eta[10000]; intree->SetBranchStatus("Track_eta", 1); intree->SetBranchAddress("Track_eta", Track_eta);
	float Track_phi[10000]; intree->SetBranchStatus("Track_phi", 1); intree->SetBranchAddress("Track_phi", Track_phi);
	float Track_chi2[10000]; intree->SetBranchStatus("Track_chi2", 1); intree->SetBranchAddress("Track_chi2", Track_chi2);
	int Track_charge[10000]; intree->SetBranchStatus("Track_charge", 1); intree->SetBranchAddress("Track_charge", Track_charge);
	int Track_history[10000]; intree->SetBranchStatus("Track_history", 1); intree->SetBranchAddress("Track_history", Track_history);
	int Track_nHitStrip[10000]; intree->SetBranchStatus("Track_nHitStrip", 1); intree->SetBranchAddress("Track_nHitStrip", Track_nHitStrip);
	int Track_nHitPixel[10000]; intree->SetBranchStatus("Track_nHitPixel", 1); intree->SetBranchAddress("Track_nHitPixel", Track_nHitPixel);
	int Track_nHitAll[10000]; intree->SetBranchStatus("Track_nHitAll", 1); intree->SetBranchAddress("Track_nHitAll", Track_nHitAll);
	int Track_nHitTIB[10000]; intree->SetBranchStatus("Track_nHitTIB", 1); intree->SetBranchAddress("Track_nHitTIB", Track_nHitTIB);
	int Track_nHitTID[10000]; intree->SetBranchStatus("Track_nHitTID", 1); intree->SetBranchAddress("Track_nHitTID", Track_nHitTID);
	int Track_nHitTOB[10000]; intree->SetBranchStatus("Track_nHitTOB", 1); intree->SetBranchAddress("Track_nHitTOB", Track_nHitTOB);
	int Track_nHitTEC[10000]; intree->SetBranchStatus("Track_nHitTEC", 1); intree->SetBranchAddress("Track_nHitTEC", Track_nHitTEC);
	int Track_nHitPXB[10000]; intree->SetBranchStatus("Track_nHitPXB", 1); intree->SetBranchAddress("Track_nHitPXB", Track_nHitPXB);
	int Track_nHitPXF[10000]; intree->SetBranchStatus("Track_nHitPXF", 1); intree->SetBranchAddress("Track_nHitPXF", Track_nHitPXF);
	int Track_isHitL1[10000]; intree->SetBranchStatus("Track_isHitL1", 1); intree->SetBranchAddress("Track_isHitL1", Track_isHitL1);
	// int Track_nSiLayers[10000]; intree->SetBranchStatus("Track_nSiLayers", 1); intree->SetBranchAddress("Track_nSiLayers", Track_nSiLayers);
	// int Track_nPxLayers[10000]; intree->SetBranchStatus("Track_nPxLayers", 1); intree->SetBranchAddress("Track_nPxLayers", Track_nPxLayers);
	float Track_PVweight[10000]; intree->SetBranchStatus("Track_PVweight", 1); intree->SetBranchAddress("Track_PVweight", Track_PVweight);
	float Track_SVweight[10000]; intree->SetBranchStatus("Track_SVweight", 1); intree->SetBranchAddress("Track_SVweight", Track_SVweight);
	int Track_isfromSV[10000]; intree->SetBranchStatus("Track_isfromSV", 1); intree->SetBranchAddress("Track_isfromSV", Track_isfromSV);
	int Track_isfromV0[10000]; intree->SetBranchStatus("Track_isfromV0", 1); intree->SetBranchAddress("Track_isfromV0", Track_isfromV0);
	int Track_category[10000]; intree->SetBranchStatus("Track_category", 1); intree->SetBranchAddress("Track_category", Track_category);
	// float Track_dxyErr[10000]; intree->SetBranchStatus("Track_dxyErr", 1); intree->SetBranchAddress("Track_dxyErr", Track_dxyErr);
	// float Track_dzErr[10000]; intree->SetBranchStatus("Track_dzErr", 1); intree->SetBranchAddress("Track_dzErr", Track_dzErr);
	// int Track_ndof[10000]; intree->SetBranchStatus("Track_ndof", 1); intree->SetBranchAddress("Track_ndof", Track_ndof);
	// int Track_quality[10000]; intree->SetBranchStatus("Track_quality", 1); intree->SetBranchAddress("Track_quality", Track_quality);
	// int Track_nLostHits[10000]; intree->SetBranchStatus("Track_nLostHits", 1); intree->SetBranchAddress("Track_nLostHits", Track_nLostHits);
	// int Track_nInactiveHits[10000]; intree->SetBranchStatus("Track_nInactiveHits", 1); intree->SetBranchAddress("Track_nInactiveHits", Track_nInactiveHits);

	/*
		TO BE USED IF ADDING TAGGING VARS TO THE GAME
	 */
	// int nTrkTagVar=0; intree->SetBranchStatus("nTrkTagVar", 1); intree->SetBranchAddress("nTrkTagVar", &nTrkTagVar);
	// float TagVar_trackMomentum[10000]; intree->SetBranchStatus("TagVar_trackMomentum", 1); intree->SetBranchAddress("TagVar_trackMomentum", TagVar_trackMomentum);
	// float TagVar_trackPtRel[10000]; intree->SetBranchStatus("TagVar_trackPtRel", 1); intree->SetBranchAddress("TagVar_trackPtRel", TagVar_trackPtRel);
	// float TagVar_trackPPar[10000]; intree->SetBranchStatus("TagVar_trackPPar", 1); intree->SetBranchAddress("TagVar_trackPPar", TagVar_trackPPar);
	// float TagVar_trackEtaRel[10000]; intree->SetBranchStatus("TagVar_trackEtaRel", 1); intree->SetBranchAddress("TagVar_trackEtaRel", TagVar_trackEtaRel);
	// float TagVar_trackDeltaR[10000]; intree->SetBranchStatus("TagVar_trackDeltaR", 1); intree->SetBranchAddress("TagVar_trackDeltaR", TagVar_trackDeltaR);
	// float TagVar_trackPtRatio[10000]; intree->SetBranchStatus("TagVar_trackPtRatio", 1); intree->SetBranchAddress("TagVar_trackPtRatio", TagVar_trackPtRatio);
	// float TagVar_trackPParRatio[10000]; intree->SetBranchStatus("TagVar_trackPParRatio", 1); intree->SetBranchAddress("TagVar_trackPParRatio", TagVar_trackPParRatio);
	// float TagVar_trackSip2dVal[10000]; intree->SetBranchStatus("TagVar_trackSip2dVal", 1); intree->SetBranchAddress("TagVar_trackSip2dVal", TagVar_trackSip2dVal);
	// float TagVar_trackSip2dSig[10000]; intree->SetBranchStatus("TagVar_trackSip2dSig", 1); intree->SetBranchAddress("TagVar_trackSip2dSig", TagVar_trackSip2dSig);
	// float TagVar_trackSip3dVal[10000]; intree->SetBranchStatus("TagVar_trackSip3dVal", 1); intree->SetBranchAddress("TagVar_trackSip3dVal", TagVar_trackSip3dVal);
	// float TagVar_trackSip3dSig[10000]; intree->SetBranchStatus("TagVar_trackSip3dSig", 1); intree->SetBranchAddress("TagVar_trackSip3dSig", TagVar_trackSip3dSig);
	// float TagVar_trackDecayLenVal[10000]; intree->SetBranchStatus("TagVar_trackDecayLenVal", 1); intree->SetBranchAddress("TagVar_trackDecayLenVal", TagVar_trackDecayLenVal);
	// float TagVar_trackDecayLenSig[10000]; intree->SetBranchStatus("TagVar_trackDecayLenSig", 1); intree->SetBranchAddress("TagVar_trackDecayLenSig", TagVar_trackDecayLenSig);
	// float TagVar_trackJetDistVal[10000]; intree->SetBranchStatus("TagVar_trackJetDistVal", 1); intree->SetBranchAddress("TagVar_trackJetDistVal", TagVar_trackJetDistVal);
	// float TagVar_trackJetDistSig[10000]; intree->SetBranchStatus("TagVar_trackJetDistSig", 1); intree->SetBranchAddress("TagVar_trackJetDistSig", TagVar_trackJetDistSig);


	//open output file
	TFile* outfile = TFile::Open(vars["output"].as<string>().c_str(), "recreate");
	if(!outfile) {
		throw runtime_error("Could not open input file");
	}

	TTree* outtree = new TTree("tree","tree");
	//copy vars above
	outtree->Branch("lheFilter", &lheFilter);
	outtree->Branch("mcweight", &mcweight);
	outtree->Branch("nPV", &nPV);
	outtree->Branch("rho", &rho);
	float Jetpt;  outtree->Branch("Jet_pt" , &Jetpt);
	float Jeteta; outtree->Branch("Jet_eta", &Jeteta);
	float Jetphi; outtree->Branch("Jet_phi", &Jetphi);
	uint32_t jetID; outtree->Branch("Jet_uuid", &jetID);
	int Jetflavour;   outtree->Branch("Jet_flavour"  , &Jetflavour);
	int JetnbHadrons; outtree->Branch("Jet_nbHadrons", &JetnbHadrons);
	int JetncHadrons; outtree->Branch("Jet_ncHadrons", &JetncHadrons);
	float dxy;  outtree->Branch("dxy", &dxy);
	float dz;  outtree->Branch("dz", &dz);
	float length; outtree->Branch("length", &length);
	float dist; outtree->Branch("dist", &dist);
	float IP2D; outtree->Branch("IP2D", &IP2D);
	float IP2Dsig; outtree->Branch("IP2Dsig", &IP2Dsig);
	float IP2Derr; outtree->Branch("IP2Derr", &IP2Derr);
	float IP; outtree->Branch("IP", &IP);
	float IPsig; outtree->Branch("IPsig", &IPsig);
	float IPerr; outtree->Branch("IPerr", &IPerr);
	float p;   outtree->Branch("p", &p);
	float pt;  outtree->Branch("pt", &pt);
	float eta; outtree->Branch("eta", &eta);
	float phi; outtree->Branch("phi", &phi);
	float chi2; outtree->Branch("chi2", &chi2);
	int charge;  outtree->Branch("charge" , &charge);
	int history; outtree->Branch("history", &history);
	int nHitStrip; outtree->Branch("nHitStrip", &nHitStrip);
	int nHitPixel; outtree->Branch("nHitPixel", &nHitPixel);
	int nHitAll; outtree->Branch("nHitAll", &nHitAll);
	int nHitTIB; outtree->Branch("nHitTIB", &nHitTIB);
	int nHitTID; outtree->Branch("nHitTID", &nHitTID);
	int nHitTOB; outtree->Branch("nHitTOB", &nHitTOB);
	int nHitTEC; outtree->Branch("nHitTEC", &nHitTEC);
	int nHitPXB; outtree->Branch("nHitPXB", &nHitPXB);
	int nHitPXF; outtree->Branch("nHitPXF", &nHitPXF);
	int isHitL1; outtree->Branch("isHitL1", &isHitL1);
	// int nSiLayers; outtree->Branch("nSiLayers", &nSiLayers);
	// int nPxLayers; outtree->Branch("nPxLayers", &nPxLayers);
	float PVweight; outtree->Branch("PVweight", &PVweight);
	float SVweight; outtree->Branch("SVweight", &SVweight);
	int isfromSV; outtree->Branch("isfromSV", &isfromSV);
	int isfromV0; outtree->Branch("isfromV0", &isfromV0);
	int category; outtree->Branch("category", &category);
	// float dxyErr; outtree->Branch("dxyErr", &dxyErr);
	// float dzErr ; outtree->Branch("dzErr" , &dzErr);
	// int ndof; outtree->Branch("ndof", &ndof);
	// int quality; outtree->Branch("quality", &quality);
	// int nLostHits; outtree->Branch("nLostHits", &nLostHits);
	// int nInactiveHits; outtree->Branch("nInactiveHits", &nInactiveHits);
	/*
		TO BE USED IF ADDING TAGGING VARS TO THE GAME
	*/
	// float ptRel;  outtree->Branch("ptRel", &ptRel);
	// float pPar;   outtree->Branch("pPar", &pPar);
	// float etaRel; outtree->Branch("etaRel", &etaRel);
	// float deltaR; outtree->Branch("deltaR", &deltaR);
	// float ptRatio; outtree->Branch("ptRatio", &ptRatio);
	// float pParRatio;  outtree->Branch("pParRatio", &pParRatio);
	// float sip2dVal;  outtree->Branch("sip2dVal", &sip2dVal);
	// float sip2dSig;  outtree->Branch("sip2dSig", &sip2dSig);
	// float sip3dVal;  outtree->Branch("sip3dVal", &sip3dVal);
	// float sip3dSig;  outtree->Branch("sip3dSig", &sip3dSig);
	// float decayLenVal; outtree->Branch("decayLenVal", &decayLenVal);
	// float decayLenSig; outtree->Branch("decayLenSig", &decayLenSig);
	// float jetDistVal; outtree->Branch("jetDistVal", &jetDistVal);
	// float jetDistSig; outtree->Branch("jetDistSig", &jetDistSig);

	//unpacking of boolean flags
	// bool loose; outtree->Branch("loose", &loose);
	// bool highpurity; outtree->Branch("highpurity", &highpurity);
	// bool tight; outtree->Branch("tight", &tight);
	// bool discarded; outtree->Branch("discarded", &discarded);
	
	jetID = 0;
	for(long int entry=0; entry < intree->GetEntries(); ++entry) { //evt loop
		if(entry % 1000 == 0) cout << "Processing entry " << entry << endl;
		intree->GetEntry(entry);
		for(int ijet=0; ijet<nJet; ijet++) { //jet loop
			Jetpt  = Jet_pt[ijet];
			Jeteta = Jet_eta[ijet];
			Jetphi = Jet_phi[ijet];
			Jetflavour   = Jet_flavour[ijet];
			JetnbHadrons = Jet_nbHadrons[ijet];
			JetncHadrons = Jet_ncHadrons[ijet];
				
			/*
				TO BE USED IF ADDING TAGGING VARS TO THE GAME
			*/
			// if(nTrkTagVar != nTrack) {
			// 	throw runtime_error("The entry has a different number of track tagging variables and track variables, probably you ran BTagAnalyzer with the wrong configuration!");
			// }
			// map<float, int> momentum_mapping;
			// for(int itrack=Jet_nFirstTrack[ijet]; itrack<Jet_nLastTrack[ijet]; ++itrack) {//first track loop
			// 	momentum_mapping[Track_p[itrack]] = itrack;
			// }//first track loop
			
			for(int itrack=Jet_nFirstTrack[ijet]; itrack<Jet_nLastTrack[ijet]; ++itrack) {//second track loop (and filling)
				/*
					TO BE USED IF ADDING TAGGING VARS TO THE GAME
				*/
				//tagging vars
				// ptRel       = TagVar_trackPtRel[itrack]; 			   
				// pPar			  = TagVar_trackPPar[itrack];  			
				// etaRel		  = TagVar_trackEtaRel[itrack];			
				// deltaR		  = TagVar_trackDeltaR[itrack];			
				// ptRatio		  = TagVar_trackPtRatio[itrack];		
				// pParRatio	  = TagVar_trackPParRatio[itrack];	
				// sip2dVal	  = TagVar_trackSip2dVal[itrack];		
				// sip2dSig	  = TagVar_trackSip2dSig[itrack];		
				// sip3dVal	  = TagVar_trackSip3dVal[itrack];		
				// sip3dSig	  = TagVar_trackSip3dSig[itrack];		
				// decayLenVal = TagVar_trackDecayLenVal[itrack];
				// decayLenSig = TagVar_trackDecayLenSig[itrack];
				// jetDistVal  = TagVar_trackJetDistVal[itrack];	
				// jetDistSig  = TagVar_trackJetDistSig[itrack]; 				
				//access track info through momentum mapping
				int trkidx = itrack; //momentum_mapping.at(TagVar_trackMomentum[itrack]); //this could crash!
	
				dxy           = Track_dxy[trkidx];					
				dz						= Track_dz[trkidx];						
				length				= Track_length[trkidx];				
				dist					= Track_dist[trkidx];					
				IP2D					= Track_IP2D[trkidx];					
				IP2Dsig				= Track_IP2Dsig[trkidx];			
				IP2Derr				= Track_IP2Derr[trkidx];			
				IP						= Track_IP[trkidx];						
				IPsig					= Track_IPsig[trkidx];				
				IPerr					= Track_IPerr[trkidx];				
				p							= Track_p[trkidx];						 
				pt						= Track_pt[trkidx];					 
				eta						= Track_eta[trkidx];					 	
				phi						= Track_phi[trkidx];					 
				chi2					= Track_chi2[trkidx];				 
				charge				= Track_charge[trkidx];			 	
				history				= Track_history[trkidx];			 	
				nHitStrip			= Track_nHitStrip[trkidx];		 
				nHitPixel			= Track_nHitPixel[trkidx];		 
				nHitAll				= Track_nHitAll[trkidx];			 
				nHitTIB				= Track_nHitTIB[trkidx];			 
				nHitTID				= Track_nHitTID[trkidx];			 
				nHitTOB				= Track_nHitTOB[trkidx];			 
				nHitTEC				= Track_nHitTEC[trkidx];			 
				nHitPXB				= Track_nHitPXB[trkidx];			 
				nHitPXF				= Track_nHitPXF[trkidx];			 
				isHitL1				= Track_isHitL1[trkidx];			 
				// nSiLayers			= Track_nSiLayers[trkidx];		 
				// nPxLayers			= Track_nPxLayers[trkidx];		 
				PVweight			= Track_PVweight[trkidx];		 
				SVweight			= Track_SVweight[trkidx];		 	
				isfromSV			= Track_isfromSV[trkidx];		 	
				isfromV0			= Track_isfromV0[trkidx];		 	
				category			= Track_category[trkidx];		 	
				// dxyErr				= Track_dxyErr[trkidx];			 	
				// dzErr 				= Track_dzErr[trkidx];				 	
				// ndof					= Track_ndof[trkidx];				 
				// quality				= Track_quality[trkidx];			 	
				// nLostHits			= Track_nLostHits[trkidx];		 
				// nInactiveHits	= Track_nInactiveHits[trkidx];

				//flags
				// loose = (quality & 1);
				// tight = (quality & (1 << 1)) >> 1;
				// highpurity = (quality & (1 << 2)) >> 2;
				// discarded = (quality & (1 << 7)) >> 7;
								 
				outtree->Fill();	
			}
			jetID++;
		} //jet loop
	} //evt loop
	outfile->cd();
	outfile->Write();
}
